<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Knightify Photo Booth</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { font-family: Arial, sans-serif; background: #181d27; color: #fff; text-align: center; }
    .container { margin: 30px auto; max-width: 500px; padding: 30px; background: #232941; border-radius: 18px; box-shadow: 0 2px 18px #1114; }
    h1 { margin-bottom: 24px; }
    label, button { font-size: 1.1em; margin: 8px 0; }
    input[type="file"], #webcam-capture { margin: 12px 0; }
    #preview, #result-image { margin-top: 16px; max-width: 90%; border-radius: 12px; }
    #loading { margin: 18px 0; color: #fff176; font-weight: bold; }
    .error { color: #ff5252; margin: 10px 0; }
    .success { color: #6aff70; }
    #webcam-stream { width: 90%; max-width: 320px; margin: 12px auto; border-radius: 10px; border: 2px solid #333; display: block; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Become a Knight!</h1>
    <form id="upload-form">
      <div>
        <label>
          <input type="radio" name="source" value="upload" checked> Upload a photo
        </label>
        <label>
          <input type="radio" name="source" value="webcam"> Use webcam
        </label>
      </div>
      <input type="file" id="file-input" accept="image/*"><br>
      <div id="webcam-area" style="display:none;">
        <video id="webcam-stream" autoplay></video><br>
        <button id="webcam-capture" type="button">Capture Photo</button>
        <canvas id="webcam-canvas" style="display:none;"></canvas>
      </div>
      <img id="preview" style="display:none;">
      <div>
        <input type="hidden" id="prompt-input" value="Ultra photorealistic. Keep the subject's face, skin, eyes, mouth, ears, hair, facial structure, ethnicity, gender, and unique physical features 100% identical to the input photo with no changes. Do not alter or stylize the face, head, body, or proportions. Only change clothing to ornate medieval knight armor and change the background to a cinematic, realistic epic fantasy castle scene. The image must look exactly like the real person in the photo, not a painting or drawing. No artistic filter. No changes to the subject's pose, angle, or perspective. High detail. Masterpiece. Real light. --no different person, different face, altered face, stylized face, cartoon, painting, illustration, anime, ai artifact, bad anatomy, duplicate, face swap, new pose, extra arms, extra legs, missing limbs, watermark, text, extra fingers, rendered, avatar, low quality, filter, smoothing, smoothing skin, smoothing face, exaggerated features, photobash, composite">
      </div>
      <button type="submit" id="submit-btn">Transform Me</button>
    </form>
    <div id="loading"></div>
    <div class="error" id="error"></div>
    <div>
      <img id="result-image" style="display:none;">
      <br>
      <a id="download-link" style="display:none;" download="knightified.jpg">Download Result</a>
    </div>
  </div>
  <script>
    // Elements
    const fileInput = document.getElementById('file-input');
    const webcamArea = document.getElementById('webcam-area');
    const webcamStream = document.getElementById('webcam-stream');
    const webcamCaptureBtn = document.getElementById('webcam-capture');
    const webcamCanvas = document.getElementById('webcam-canvas');
    const preview = document.getElementById('preview');
    const promptInput = document.getElementById('prompt-input');
    const form = document.getElementById('upload-form');
    const loading = document.getElementById('loading');
    const errorDiv = document.getElementById('error');
    const resultImg = document.getElementById('result-image');
    const downloadLink = document.getElementById('download-link');
    let lastImageBlob = null;
    let webcamStreamTrack = null;

    // Handle source switching
    document.querySelectorAll('input[name="source"]').forEach(radio => {
      radio.onchange = () => {
        if (radio.value === "webcam") {
          fileInput.style.display = "none";
          webcamArea.style.display = "";
          preview.style.display = "none";
          startWebcam();
        } else {
          fileInput.style.display = "";
          webcamArea.style.display = "none";
          preview.style.display = "none";
          stopWebcam();
        }
      };
    });

    // Webcam capture
    function startWebcam() {
      navigator.mediaDevices.getUserMedia({ video: true })
        .then(stream => {
          webcamStream.srcObject = stream;
          webcamStreamTrack = stream;
        })
        .catch(err => {
          errorDiv.textContent = "Could not access webcam: " + err.message;
        });
    }
    function stopWebcam() {
      if (webcamStreamTrack) {
        webcamStreamTrack.getTracks().forEach(track => track.stop());
        webcamStreamTrack = null;
      }
    }
    webcamCaptureBtn.onclick = function () {
      webcamCanvas.width = webcamStream.videoWidth;
      webcamCanvas.height = webcamStream.videoHeight;
      webcamCanvas.getContext('2d').drawImage(webcamStream, 0, 0);
      webcamCanvas.toBlob(blob => {
        lastImageBlob = blob;
        const url = URL.createObjectURL(blob);
        preview.src = url;
        preview.style.display = "";
      }, 'image/jpeg', 0.96);
    };

    // File input
    fileInput.onchange = function () {
      if (fileInput.files.length > 0) {
        const file = fileInput.files[0];
        lastImageBlob = file;
        const url = URL.createObjectURL(file);
        preview.src = url;
        preview.style.display = "";
      }
    };

    // Submit
    form.onsubmit = async function (e) {
      e.preventDefault();
      errorDiv.textContent = "";
      resultImg.style.display = "none";
      downloadLink.style.display = "none";
      loading.textContent = "Uploading image...";
      // Get image blob
      if (!lastImageBlob) {
        errorDiv.textContent = "Please upload or capture an image first.";
        loading.textContent = "";
        return;
      }
      // Prepare FormData
      const fd = new FormData();
      fd.append('image', lastImageBlob);
      fd.append('prompt', promptInput.value);

      try {
        // Send to Netlify function
        loading.textContent = "Processing transformation. This may take up to 40 seconds...";
        const resp = await fetch('/.netlify/functions/userapi-proxy-background', {
          method: 'POST',
          body: fd
        });
        let json;
        try {
          json = await resp.json();
        } catch (err) {
          errorDiv.textContent = "Server returned invalid response.";
          loading.textContent = "";
          return;
        }
        if (!json.success) {
          errorDiv.textContent = json.error || "Transformation failed. Please try again.";
          loading.textContent = "";
          return;
        }
        resultImg.src = json.result;
        resultImg.style.display = "";
        downloadLink.href = json.result;
        downloadLink.style.display = "";
        loading.textContent = "";
      } catch (err) {
        errorDiv.textContent = "Network or server error: " + err;
        loading.textContent = "";
      }
    };
    window.onbeforeunload = stopWebcam;
  </script>
</body>
</html>
